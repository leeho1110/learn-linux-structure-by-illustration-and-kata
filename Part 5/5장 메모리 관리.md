# 5장: 메모리 관리

### 개요

프로그램을 실행하기 위해선 필요한 것은 많습니다. 그 중 반드시 필요한 것은 CPU와 메모리입니다. 이번 장에서는 리눅스가 단순히 물리적 메모리가 갖고 있는 한계를 어떤 기술들을 통해 극복했는지 알아봅니다.

---

### 메모리의 통계 정보

- 리눅스에선 사용중인 메모리의 여러 정보들을 `free` 명령어를 통해 확인할 수 있습니다. KB단위로 표기되며 아래는 확인할 수 있는 메모리 정보의 종류입니다.
    1. **total**: 시스템에 탑재된 전체 메모리의 용량을 의미합니다. 
    2. **free**: 표기상(중요) 이용하지 않는 메모리의 용량입니다.
    3. **buff/cache**: 버퍼 캐시 혹은 페이지 캐시가 이용하는 메모리입니다. free 필드에 표기되는 사용 가능한 메모리가 없을 때 커널이 추가 할당을 위해 해제하는 영역입니다.
    4. **available**: free 필드에서 이용하지 않는 메모리라는 표현을 사용했습니다. buff/cache 필드는 커널이 확장을 위해 해제 가능한 영역이었습니다. 이 둘을 합치면 최대로 사용 가능한 메모리 영역의 크기가 도출됩니다. availbale은 free 메모리에 부족할 때 해제되는 메모리 영역 사이즈까지 더한 크기입니다.

---

### 메모리의 부족과 OOM Killer

- 만약 정말 사용할 메모리가 없다면 메모리는 Out Of Memory, 일명 OOM 상태가 됩니다. 이 때 리눅스의 메모리 관리 시스템은 적절한 프로세스를 선택해 kill 해버립니다.
    - OOM Killer와 관련된 이슈들은 정말 많습니다. 그 중 서버 애플리케이션의 경우 대부분 자바 프로세스가 kill 되게 되는데요. 그 시간동안 해당 서버가 서비스를 운용하지 못하기 때문에 장애로 이어질 수 있습니다. 아래는 OOM Killer가 발생했을 때 Java Native Memory Leak에 대해 토스에서 공개한 세션입니다.
    - [토스ㅣSLASH 22 - Java Native Memory Leak 원인을 찾아서](https://www.youtube.com/watch?v=w4fWgLgop5U)

---

### 왜 가상 메모리가 필요할까?

- 우선 가상 메모리가 어떻게 사용되는지를 알기 전에 항상 중요한 “왜?”라는 질문부터 던져보겠습니다. 컴퓨터가 만들어질 때부터 가상 메모리를 사용한 것은 아닙니다. 물리 메모리만 사용해도 여러 프로그램들을 실행할 수 있습니다. 하지만 그럼에도 불구하고 우린 가상 메모리를 사용합니다. 그 이유는 무엇일까요?
    1. 메모리 단편화
        - 수많은 프로세스들이 메모리를 획득, 해제를 반복합니다. 이 때 메모리는 베스킨라빈스 아이스크림통처럼 순서대로 할당되지 않습니다. 따라서 메모리는 그 영역들이 조각조각 나눠져 있게 됩니다. 이를 메모리 단편화 현상이라고 말합니다.
        - 물론 나눠진 메모리를 합쳐서 사용하면 되지 않느냐? 라고 반문하실 수 있지만 프로그램이 일일히 나눠진 영역을 확인해야하는 단점이 있습니다. 만약 쪼개진 곳 여러 개를 이어야만 할당할 수 있는 크기의 프로그램이 있는 경우도 메모리 획득이 불가능하죠. 즉 메모리 단편화 현상은 효율적인 메모리 사용을 위해 반드시 필요합니다.
    2. 다른 영역의 메모리 접근
        - 프로세스가 직접 메모리 주소를 지정하는 경우라면 다른 프로세스가 사용하는 메모리에도 접근이 가능합니다. 이렇게 되면 내부의 데이터를 마음대로 수정하는 메모리 오염이 발생합니다.
        - 심지어 운영체제에서 가장 중요한 커널까지도 그 위험성이 존재합니다. 당연히 안되겠죠?
    3. 멀티프로세싱 환경에서의 메모리 핸들링
        - 멀티프로세싱에서 동일한 프로그램을 여러 개 실행한다고 가정해보겠습니다. 우리는 앞서 프로그램이 메모리 맵을 통해 어느 위치에 코드와 데이터가 위치해야하는지를 명시하는 것을 확인했습니다. 하지만 위 경우라면 이미 동일한 프로그램이 해당 영역을 사용하고 있기 때문에 불가능합니다.
- 즉 위의 3가지 문제점은 직접 물리 메모리를 할당하는 방식에서 발생할 수 있습니다. 자연스럽게 한계를 개선하기 위한 방법들이 여러 가지 나오게 되는데요. 그 중 가장 성공적인 방법이 바로 **가상 메모리 기법**입니다.

---

### 가상 메모리의 추상화 모델

- 앞서 우린 프로세스를 물리 메모리에 직접 매핑했습니다. 하지만 가상 메모리 시스템에서 매핑된 주소들은 전부 가상 주소 혹은 가상 주소 공간이라고 부릅니다. 그렇다면 물리 주소와도 당연히 매핑이 되어있겠죠? 매핑을 기록하는 곳을 바로 **페이지 엔트리 테이블**이라고 하며 x_86_64(64bit) 아키텍처에서는 일반적으로 4KB의 크기를 갖습니다. 가상 메모리 주소들은 페이지 엔트리 테이블들에 저장된 정보를 통해 물리적 주소로 변환됩니다.
- 이 때 할당되는 메모리는 가상 메모리와 물리적 메모리는 페이지라는 작은 조각으로 나눠집니다. 페이지들은 일반적으로 관리의 용이성 때문에 일반적으로 같은 크기를 갖습니다.
    - 리눅스는 알파 AXP 시스템에서는 8KB 페이지를, 인텔 x86 시스템에서는 4KB 페이지를 사용하며, 나눠진 각 페이지에는 페이지 프레임 번호(page frame number, PFN)라는 유일 식별값이 부여됩니다.
        - 이 때 페이지 엔트리 테이블에 매핑된 가상 주소는 페이지 프레임 번호와 오프셋으로 구성됩니다.
        - 프로세스는 커널의 물리 주소 변환을 통해 물리 메모리에 접근합니다. CPU 안에서 이런 물리 주소 변환을 수행하는 하드웨어를 우린 **Memory Management Unit(MMU)** 라고 부릅니다.
- 이 때 만약 실제 물리 메모리가 할당되지 않은 가상 주소에 접근하려고 한다면 어떻게 될까요? 유효한 변환이 불가능한 주소에 접근하려고 했다는 사실을 **페이지 폴트(page fault)** 라는 인터럽트를 CPU에게 전달하는 것을 통해 알립니다.
    - 이 때 커널은 프로세스로부터 메모리 접근이 잘못됐다는 것을 페이지 폴트 핸들러에게 전달합니다. 이 후 SEGEGV 시그널을 프로세스에 통지하고 전달받은 프로세스는 강제 종료됩니다.
- 다만 운영체제 스스로는 가상 메모리에서 동작하지 않습니다. 그렇게 되면 운영체제가 스스로를 위한 페이지 테이블가 필요한 상황이기 때문입니다. 따라서 일반적으로 CPU는 물리 모드와 가상 모드를 동시에 제공합니다.
    - 물리 모드에서는 CPU는 실제 메모리 주소를 사용하기 때문에 페이지 테이블이 필요 없습니다. 동시에 어떤 주소 변환 로직도 필요가 없습니다.

---

### 고수준 레벨에서의 메모리 할당

- 일반적으로 제가 사용하고 있는 언어 Java는 개발자가 직접 메모리를 핸들링하지 않습니다. 하지만 고수준 언어지만 상대적으로 로우 레벨인 C는 표준 라이브러리의 함수를 통해 직접 핸들링합니다.
    - 사용되는 함수는 `malloc()` 입니다. 아마 memory allocation의 약자로 예상됩니다. C에서 이 함수를 호출하면 리눅스는 내부적으로 `mmap()` 함수를 통해 메모리를 할당합니다.
    - `mmap()` 함수와 `malloc()` 함수는 확보하려는 메모리의 단위가 페이지 단위와 바이트 단위로 다릅니다. 따라서 C의 glibc는 미리 `mmap()` 시스템 콜을 이용해 메모리 풀(커다란 메모리 영역)을 만들어 놓습니다. 이 후 `malloc()`이 호출되면 필요한 바이트만큼 메모리 풀에서 잘라 반환합니다.
        - 만약 메모리 풀에서 가져올 여분이 없는 경우 다시 `mmap()` 를 호출해 새로운 영역을 확보합니다.

---

### 가상 메모리의 솔루션

- 앞서 메모리의 물리 주소를 직접 이용할 때 발생하는 문제 3가지를 확인했습니다. 과연 가상 메모리에서는 이를 어떻게 해결할까요?
    - 메모리 단편화: 문제는 연속된 메모리 할당이 불가능하다는 것이었습니다. 하지만 가상 주소를 사용하면 실제 물리 주소는 분리되어있을지라도 가상 주소에서는 연속적이기 때문에 해결 가능합니다.
    - 다른 영역의 메모리 접근: 페이지 테이블 엔트리는 기본적으로 프로세스 당 하나씩 생성됩니다. 즉 프로세스가 접근할 수 있는 메모리는 자신의 페이지 테이블 엔트리로 제한됩니다. 다른 영역? 어림도 없죠.
    - 멀티프로세싱 환경에서의 메모리 핸들링: 이 역시 위와 똑같습니다. 프로세스마다 페이지 테이블 엔트리가 존재하기 때문에 걱정할 필요가 없습니다.

---

### 가상 메모리의 응용

- 파일 맵
    - 프로세스가 파일에 접근할 때 `mmap()` 함수를 특정 방법으로 호출하면 파일을 메모리에 읽은 뒤, 이를 가상 주소 공간에 매핑할 수 있습니다. 만약 파일 저장 장치에 저장된 파일에 쓰기 작업을 하고 싶다면 매핑된 영역에 작업을 수행하면 됩니다. 이 후 적절한 타이밍에 이를 파일에 옮깁니다.
- 디맨드 페이징
    - 우리는 앞서 메모리 풀에서 메모리를 잘라 가상 주소와 물리 주소를 매핑한다고 말했습니다. 하지만 확보한 메모리 중에 사용되지 않는 영역이 있다면 어떨까요? 당연히 낭비입니다. 따라서 이런 메모리 낭비를 효율화하기 위해 디맨드 페이징이 등장했습니다.
    - 디맨드 페이징은 프로세스의 페이지 테이블 엔트리에 매핑된 각 페이지별 주소는 페이지에 처음 접근할 때 할당됩니다. 각 페이지는 ‘프로세스에 할당', ‘**프로세스에는 할당됐지만 물리 메모리에는 할당되지 않음**', ‘프로세스와 물리 메모리에도 할당' 이라는 총 3가지의 상태를 가지게 됩니다.
        - 이 때 마지막 상태인 프로세스와 물리 메모리가 할당되기 전에 만약 접근한다면 실제 물리 메모리 주소를 갖고 있지 않아 페이지 폴트가 발생합니다.
        - 이 경우 커널의 페이지 폴트 핸들러는 접근한 페이지에 물리 메모리를 할당하고 페이지 폴트를 제거합니다. 그리고 프로그램 실행을 계속합니다. 이 때 프로세스는 자신이 접근한 주소가 유효하지 않다는 사실을 모릅니다.
        - 만약 여기서 추가로 메모리가 필요하다면 `mmap()` 함수를 통해 메모리를 확보합니다. 이를 ‘가상 메모리 확보'라고 표현하고, 여기에 접근해 물리 메모리를 확보하고 매핑하는 것은 ‘물리 메모리 확보'라고 표현합니다.
        - 만약 가상 메모리의 확보와 상관없이 메모리에 쓰기를 하는 시점에 물리 메모리가 없다면 OOM이 발생합니다.
- Copy on Write
- 스왑
- 계층형 페이지 테이블
- Huge page